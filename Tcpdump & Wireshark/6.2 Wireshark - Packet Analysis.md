## Packet Analysis 

## Task 1. Explore data with Wireshark
1. To open the packet capture file, I double-clicked the sample file on the Windows desktop and this started Wireshark.

![Open the Packet Capture file](https://github.com/user-attachments/assets/37427b29-195f-4e45-a2f6-cb1000d44407)

2. Once Wireshark started I double-clicked the Wireshark title bar next to the sample.pcap filename in order to maximize the Wireshark application window.
* **Note:** Not all the data packets are the same color. Coloring rules are used to provide high-level visual cues to help you quickly classify the different types of data. Since network packet capture files can contain large amounts of data, we can use coloring rules to quickly identify the data that is relevant. The example packet lists a group of **light blue** packets that all contain `DNS` traffic, followed by **green** packets that contain a mixture of `TCP` and `HTTP` protocol traffic.*
  
![Capture File](https://github.com/user-attachments/assets/3f1cd043-14c1-4c66-9002-d8fe114b529e)

* A lot of network packet traffic is listed, and this requires the use of filters in order to find the information during an investigation.

An overview of the key property columns listed for each packet: 
* `No` : The index number of the packet in this packet capture file.
* `Time`: The timestamp of the packet.
* `Source`: The source IP address.
* `Destination`: The destination IP address.
* `Protocol`: The protocol contained in the packet.
* `Length`: The total length of the packet.
* `Info`: Some infomation about the data in the packet (the payload) as interpreted by Wireshark.

## Task 2. Apply a basic Wireshark filter and inspect a packet
* In this task, I had to open a packet in Wireshark for a more detailed exploration and to filter the data in order to inspect the network layers and protocols contained in the packet.
* After entering and applying `ip.addr == 142.250.1.139` into the search tab the list of packets displayed is now significantly reduced and contain only packets where either the source or the destination IP address matches the address I've entered. Now only two packet colors are used: **light pink** for `ICMP` protocol packets and **light green** for `TCP` (and `HTTP`, which is a subset of `TCP`) packets..

![ip.addr == 142.250.1.139 Search](https://github.com/user-attachments/assets/f958f17d-4a76-44ba-913b-5056ee13b685)

After double-clicking the first packet that lists TCP as the protocol it opens a packet details pane window as shown below:

![ip.addr == 142.250.1.139 Search TCP Protocol](https://github.com/user-attachments/assets/5eca4994-f9ad-412d-91d3-51fd99049bf6)

The upper section of the window above contains subtrees where Wireshark provides an analysis of the various parts of the network packet. The lower section of the window contains the raw packet data displayed in hexadecimal and ASCII text. There is also placeholder text for fields where the character data does not apply, as indicated by the dot (“.”).

* Double-clicking on the first subtree in the upper section with the word **Frame** provides details about the overall network packet, or frame. The details include the **frame length** and the **arrival time** of the packet that is information about the entire packet of data.

![Frame view](https://github.com/user-attachments/assets/6d2d0491-ef53-467b-bf4a-4987950dbad4)

*Double-clicking the Ethernet II subtree, produces an item which contains details about the packet at the Ethernet level, including the **source** and **destination MAC addresses** and the type of **internal protocol** that the Ethernet packet contains.

![Ethernet II subtree view](https://github.com/user-attachments/assets/bf0834d0-59ef-451e-a825-894175b8ca79)

* Double-clicking the Internet Protocol Version 4 subtree provides packet data about the **Internet Protocol (IP)** data contained in the Ethernet packet. It contains information such as the source and destination **IP addresses** and the **Internal Protocol** (for example, `TCP` or `UDP`), which is carried inside the IP packet.

![image](https://github.com/user-attachments/assets/3a4af9b6-25bd-4d94-a0a6-071c6c9a3009)

![image](https://github.com/user-attachments/assets/51fa8258-04b4-4bbd-96bc-74096f22b474)

![image](https://github.com/user-attachments/assets/27f86a35-4763-41a7-93d6-d7eeb5efb01c)

## Task 3. Using filters to select packets

![image](https://github.com/user-attachments/assets/1e723d1d-6d9a-4236-bfb7-19b463c407be)

![image](https://github.com/user-attachments/assets/79097d91-1789-415e-8e71-416eee172f37)

![image](https://github.com/user-attachments/assets/be17ccdd-44ac-4d3f-a37b-3d4542bae3eb)

![image](https://github.com/user-attachments/assets/fe009584-70ca-4da2-a904-fed2ef9e8e96)

![image](https://github.com/user-attachments/assets/2ac9bf5b-c9b0-4f31-b4c0-99e2ce545b49)

![image](https://github.com/user-attachments/assets/02c4832a-41f8-4369-9766-63cd24fe0673)

![image](https://github.com/user-attachments/assets/5b98b6ce-7d8a-47e8-8724-b4147b4b6bb0)

![image](https://github.com/user-attachments/assets/76d1f8b7-c744-4b54-8b39-806b4a5f1fac)

## Task 4. Using filters to explore DNS packets

![image](https://github.com/user-attachments/assets/fe57425f-b63c-439f-8a49-9a2b2cc6d181)

![image](https://github.com/user-attachments/assets/a08736a5-0bd4-498c-b46f-2cc6f52bd71a)

![image](https://github.com/user-attachments/assets/b2991353-d0fb-4fad-aef9-ed1f87ef2e5e)

![image](https://github.com/user-attachments/assets/f03f4318-63cc-4f55-8ab0-78df4d235635)

![image](https://github.com/user-attachments/assets/2abd3e61-84de-4d4d-b953-7dda79fd883f)

![image](https://github.com/user-attachments/assets/75ca68d3-c729-4f40-bf29-632fbbb1b32a)

![image](https://github.com/user-attachments/assets/2cf20d11-cddc-48c7-8bf7-e1e5417884d6)

![image](https://github.com/user-attachments/assets/8a288f41-9085-4bec-9ac9-adbe028b3287)

## Task 5

![image](https://github.com/user-attachments/assets/cbf889df-817b-4fba-8ed2-3ca4b588c96a)

![image](https://github.com/user-attachments/assets/0017387e-4089-400d-b925-849792eaf594)

![image](https://github.com/user-attachments/assets/e7cc06d9-9570-40b0-b060-e0816312a4fc)

![image](https://github.com/user-attachments/assets/908fa2b6-3388-472a-a063-484a1dab48ba)

![image](https://github.com/user-attachments/assets/bb8922fe-ab17-4744-ae6c-27a05e4ceb73)





* On the title bar, type `ip.dst == 142.250.1.139` to filter for traffic associated with a specific IP address. `dst` means it is where the packet goes to.
  
![chrome_0BcQ5U6PID](https://github.com/Kwangsa19/Ketmanto-Cybersecurity-Portfolio/assets/135963482/19394509-d60b-48eb-9d41-176d5bffbc00)

* On the title bar, type `eth.addr == 42:01:ac:15:e0:02` to filter for traffic associated with a specific Ethernet MAC address. `addr` means either the source or the destination IP. 

![chrome_FNyXuNAoQH](https://github.com/Kwangsa19/Ketmanto-Cybersecurity-Portfolio/assets/135963482/4385847b-0f9f-4fe5-99af-2dc3792f64f1)

2. Examine the protocols that are used when the user makes the connection to the website.
* The TCP destination port of this TCP packet is 80 when `ip.addr == 142.250.1.139` which contains the initial web request to an HTPP website that will typically be listening on TCP port 80.

![chrome_v0w4jPKpnG](https://github.com/Kwangsa19/Ketmanto-Cybersecurity-Portfolio/assets/135963482/5ce9594c-e9c3-49a2-9d93-cd0da4cb1e3b)

* The protocol destination port is TCP when Etherenet address was `42:01:ac:15:e0:02`. Source address is `172.21.224.2` and the destination address is `35.235.244.34`. 

![chrome_PAHlQSZJOk](https://github.com/Kwangsa19/Ketmanto-Cybersecurity-Portfolio/assets/135963482/263e55d9-e6e7-4204-b4c3-1215a69c98a1)

3. Analyze the data packet to identify the type of information sent and received by the systems that connect to each other when the network data is captured.
* On the title bar, type `tcp.port == 80` to filter for traffic associated with a specific port number. `tcp.port == 80` means only the tcp port is 80 will be shown. 
  
![chrome_MNHnvAhm6o](https://github.com/Kwangsa19/Ketmanto-Cybersecurity-Portfolio/assets/135963482/28081462-b634-4838-a307-b9574e7f3234)

* When the filter `tcp.port == 80` sets in play, the time to live is 64.
* `Time to Live`: A field in the Internet Protocol (IP) header that indicates the maximum amount of time an IP packet is allowed to exist in the network before it is discarded if it has not reached its destination. TTL is used to prevent packets from circulating indefinitely in the network, which could happen in the case of routing loops. It can be used as a basic security measure to limit how far packets can propagate through the network.
  
![chrome_iI9QT2BqWs](https://github.com/Kwangsa19/Ketmanto-Cybersecurity-Portfolio/assets/135963482/1fe9ba32-926b-42f3-a39e-49da54240058)


* When the filter `tcp.port == 80` sets in play, the Frame Number is 37 and Frame Length is 54 bytes.
* `Frame Number`: This is essentially the sequence number of a packet within a particular capture. It helps you identify and refer to packets more easily. In your case, a frame number of 37 means it's the 37th packet captured since the beginning of the capture session. This number is assigned sequentially as packets are captured, starting with the number 1 for the first packet.

* `Frame Length`: This indicates the size of the packet, including all headers and payload, measured in bytes. The frame length of 54 bytes means the total size of the packet is 54 bytes. This size includes everything from the lowest layer (physical layer) up to the highest layer present in the packet that Wireshark can decode. It's useful for understanding the size of the data being transmitted and can help in various analyses, such as identifying potential issues with packet sizes that might indicate fragmentation or other problems.

![chrome_xSk2HRghJg](https://github.com/Kwangsa19/Ketmanto-Cybersecurity-Portfolio/assets/135963482/107d084b-361e-4f74-98ea-c90c93fe1cae)
